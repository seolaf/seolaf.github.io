---
title: ["[GoN Open Qual CTF- web] Heliodor"]
date: 2025-09-30 09:00:00 +0900
last_modified_at: 2025-09-30 09:00:00 +0900
categories: [writeup, ctf]
tags: [web, LFI, TOCTOU]
---

## 접근 포인트
1. 입력 검증 오류  

```javascript
/* /app/heliodor/middlewares/expr.js */

const path = require('path');

/* Resolve jq expression into an absolute path. */
function jq2path(expr) {
  return path.resolve('/tmp/jsonfs/', expr.split('.').slice(1).join('/'));
}

/* Check single jq expression and save it to req.exprPath. */
function checkExprOne(req, res, next) {
  const expr = req.params.expr;
  if (
    typeof expr !== 'string' ||
    !/^(\.[0-9A-Za-z_-]*)+$/.test(expr)
  ) {
    const err = new Error("Invalid JSON query expression.");
    err.status = 400;
    return next(err);
  } else {
    req.exprPath = jq2path(expr);
    return next();
  }
}
```  

`checkExpr*`함수의 정규식이 `.[0-9A-Za-z_-]*` **빈 토큰을 허용**한다.  
즉, `jq2path()`의 `join('/')` 결과에 빈 세그먼트가 들어가면 `path.resolve()`가 절대경로로 해석해 `/tmp/jsonfs/`를 벗어날 수 있다.  

정규식에서 `*`를 `+`로 바꿨다면 공격이 불가했을 것이다.  

2. TOCTOU (`fs.stat()` → `fs.createReadStream()`)  

```javascript
/* /app/heliodor/routes/query.js */
router.get('/view/:expr', checkExprOne, function(req, res, next) {
  return res.download(req.exprPath, function(err) {
    if (err && !res.headersSent) {
      err.status = 500;
      return next(err);
    }
  });
});
```  

`res.download()`를 호출하면 내부적으로 다음과 같은 순서로 동작한다.  
1. send / sendfile 계열 라이브러리가 `fs.stat(path, cb)` 호출
   - 파일 존재 여부
   - `stats.size` (Content-Length)
   - `mtime`, `isDirectory()` 등 메타 데이터를 읽음
2. 응답 헤더 설정
   - Content-Length 또는 Range 관련 헤더 처리
3. 데이터 전송을 위한 `fs.createReadStream(path, options)` 호출
   - 내부에서 `fs.open(path, 'r', cb)`가 호출되고 새로운 fd가 반환됨
   - 스트림은 이 fd로부터 읽음

리눅스에서 `/proc/self/fd/N`은 심볼릭 링크이며, 그 링크가 가리키는 대상은 그 시점에 프로세스가 fd N으로 열고 있는 파일이다.  
- `stat("/proc/self/fd/N")`은 그 시점에 fd N이 가리키는 파일의 메타데이터를 반환
- 그사이에 fd N이 닫히고, 이후 다른 요청에서 fd N이 같은 숫자로 재할당되어 다른 파일을 가리킬 수 있음
- `createReadStream("/proc/self/fd/N")`이 실행될 때는 `open`이 새로 이루어지고, 새로운 fd를 얻고 그 fd로부터 읽음
- 그러나 Content-Length는 처음 `stat()`의 값으로 설정되어 있으므로, 서버는 새로 열린 파일을 그 길이만큼 읽어 클라이언트로 보냄

즉, 체크 시점의 객체와 사용 시점의 객체가 달라질 수 있는 TOCTOU 취약점이 발생할 수 있다.  (`stat()`의 반환값을 그대로 신뢰할 수 없다.)


## 공격 시나리오
1. LFI로 임의 경로 접근/다운로드 API를 호출 (`/query/view/<path>`)
2. `/proc/self/environ`과 같은 가상파일은 `stat()`에서 0으로 보이므로 바로 읽으면 빈 바이트가 리턴
3. 레이스 컨디션을 이용
   - 서버에 존재하는 파일(예: `/etc/passwd`)을 열어 `fd N`을 점유
   - `/proc/self/environ`을 열어 같은 fd 번호를 재할당시키도록 유도
   - `/proc/self/fd/N`을 요청해, stat에서 읽혀진 파일의 크기를 Content-Length로 사용하여 `fd N`(실제로는 `/proc/self/environ`)을 그 길이만큼 읽어오도록 함
4. 결과적으로 `/proc/self/environ`의 내용이 `/etc/passwd` 크기만큼 응답 바디에 포함되어 유출
5. 다중 스레드/병렬 요청으로 반복하여 레이스 컨디션 성공률을 올림

## 공격 성공률을 높이는 방법
레이스 컨디션의 성공률을 높이기 위해서 다양한 테크닉을 사용할 수 있다.
1. race window 늘리기
   - `stat()` 콜백과 `open()` 호출 사이에 서버가 수행하는 추가 작업이 많을 수록 race window가 늘어남
   - `Range` 요청이 들어오면, `send`는 range 파싱, 유효성 검사, `If-Range`/ETag 처리, 범위 계산 등의 추가 작업을 수행함
   - 다수의 무의미한 ranges는 파서에서 처리 루틴을 유발하여 더 많은 시간을 소모하게 함
2. fd 재사용 가능성
   - 프로세스가 열어두는 기본 fd(로그, 소켓 등) 수와 open/close 패턴에 따라 특정 fd 번호가 빠르게 재사용됨