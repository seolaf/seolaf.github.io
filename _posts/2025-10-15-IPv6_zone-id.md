---
title: ["IPv6 zone-id command injection"]
date: 2025-10-15 09:00:00 +0900
last_modified_at: 2025-10-15 09:00:00 +0900
categories: [techniques, ipv6]
tags: [web, ipv6, RFC4007, command injection]
---

```python
host = request.args.get('host', '')
try:
    addr = ipaddress.ip_address(host)
except ValueError:
    error_msg = 'Invalid IP address'
    print(error_msg)
    return render_template('index.html', result=error_msg)

cmd = f'ping -c 3 {addr}'
try:
    output = subprocess.check_output(['/bin/sh', '-c', cmd], timeout=8)
```  

위와 같은 코드에서 어떻게 Command Injection을 일으킬 수 있을까?  
`ip_address()`함수는 인자가 IP주소의 형태가 아니라면 예외를 발생시킨다.  

Command Injection을 위해 `host` 파라미터에 `8.8.8.8;ls`과 같은 값을 넣으면 `Invalid IP address`가 뜰 것이다.  

## RFC 4007
- 문제 배경: IPv6에는 `fe80::/10` 같은 link-local 주소가 존재하고, 한 호스트에는 여러 네트워크 인터페이스(예: eth0, wlan0)가 있을 수 있다. link-local 주소는 “어느 인터페이스에서 쓰느냐”가 의미를 가르기 때문에 **어느 인터페이스(또는 zone)**에서 보내야 하는지를 지정할 방법이 필요하다.
- 해결(설계): RFC 4007(IPv6 Scoped Address Architecture)은 텍스트 표현에서 IPv6 주소 뒤에 `%`로 zone identifier(일종의 scope id / interface id)를 붙여서 특정 인터페이스를 명시하는 관습을 정의했다. 예: `fe80::1%eth0` (또는 숫자 인덱스 `fe80::1%3`). 이 표기는 주로 호스트 내부에서 의미가 있으며 네트워크 전송 수준의 패킷에는 별도로 인터페이스 인덱스가 전달된다.

## python ipaddress 모듈과 zone id
`ipaddress.ip_address()`는 텍스트를 파싱해서 `IPv4Address`/`IPv6Address` 객체를 반환한다.  
`ipaddress`는 zone id를 문자열의 일부로 인식해 `::1%zone` 같은 표현을 허용한다.  

## Injection의 원리
`addr`은 `ipaddress`가 파싱한 텍스트이다. (예: `::1%eth0;ls`)  
`cmd` 문자열은 `ping -c 3 ::1%eth0;ls`이 된다.  
`sh`가 `cmd` 문자열을 해석할 때, `;`, `|` 등의 문자로 명령 체인화가 발생한다.  
즉, 쉘은 `ping -c 3 ::1%eth0`을 실행한 뒤 `ls`를 실행한다.  

## 패치 방법
가장 안전한 방법은 쉘을 사용하지 않는 것이다.  
인자 리스트로 subprocess를 실행하면 의도치 않은 문자 해석 문제를 해결할 수 있다.  
또한, zone-id를 허용해야 한다면, zone-id에 대한 검증(화이트리스트)을 해야한다.  