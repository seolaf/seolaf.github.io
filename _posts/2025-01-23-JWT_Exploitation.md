---
title: ["JWT Exploitation"]
date: 2025-01-23 09:00:00 +0900
categories: [techniques, jwt]
tags: [web, jwt]
---

# JSON Web Token(JWT)
JWT는 웹 표준(RFC 7519)에 딸 ㅏ정의된 인증 토큰으로, 주로 사용자 인증 및 정보 교환에 사용된다.  
JWT는 세 부분으로 구성된다:
* Header: 토큰의 유형과 사용된 서명 알고리즘 정보를 포함
* Payload: 사용자 정보나 클레임(claims) 등의 데이터를 포함
* Signature: Header와 Payload를 결합한 후 지정된 알고리즘과 비밀 키로 생성된 서명으로, 토큰의 무결성을 보장

## JWT의 주요 취약점
### Signature 미확인
JWT는 서명을 통해 토큰의 무결성을 검증한다. 서버가 이 서명을 확인하지 않는다면, 공격자가 JWT의 Payload를 변조해도 이를 감지할 수 없게 된다. 공격자는 이를 악용하여 권한 상승, 데이터 탈취 등 다양한 악의적인 행동을 수행할 수 있다.  

예시: 공격자가 클라이언트의 JWT에서 권한(role)을 `user`에서 `admin`으로 변경한 뒤 서버로 요청을 보낼 경우, 서버가 서명을 검증하지 않으면 변조된 토큰을 신뢰하게 된다.  

대응방안: 서버는 반드시 서명을 검증하여 토큰의 변조 여부를 확인해야 한다. 이를 위해 서버는 토큰의 Header와 Payload를 디코딩한 뒤, 저장된 비밀 키로 서명을 다시 생성하고, 이를 받은 토큰의 서명과 비교해야 한다.

### None 알고리즘 사용
JWT는 Header에서 사용하는 서명 알고리즘을 명시한다. 'None' 알고리즘은 서명을 생략하는 옵션으로, 인증 절차에서 서명 검증을 건너뛸 수 있다. 만약 서버가 'None' 알고리즘을 허용하도록 설정되어 있다면, 공격자는 서명이 없는 토큰을 생성하여 서버를 속일 수 있다.  

예시: 공격자가 JWT의 알고리즘을 'None'으로 설정하고, 서명을 제거한 상태에서 토큰을 서버로 전송하면, 서버가 이를 검증 없이 수락할 수 있다.  

대응 방안: 서버에서 반드시 'None' 알고리즘을 비활성화하고, 예상된 알고리즘(예: HS256, RS256)만 허용해야 한다.

### Algorithm Confusion Attack
알고리즘 변경 공격은 JWT에서 사용하는 서명 알고리즘의 특성을 악용하여, 공격자가 토큰의 서명을 위조하거나 변조된 토큰을 유효한 것으로 서버가 인식하도록 만드는 기법이다. 이 공격은 서버가 토큰의 알고리즘 정보를 신뢰하거나 서명 검증을 제대로 수행하지 않을 때 발생한다.  

#### 공격 원리
1. JWT의 Header에는 토큰에 사용된 서명 알고리즘(alg)이 명시되어 있다.  
    예시:
    ```json
    {
    "alg": "RS256",
    "typ": "JWT"
    }
    ```
2. 공격자는 Header의 alg 값을 대칭 알고리즘(예: HS256)으로 변경한다. 이때 RS256(비대칭 알고리즘)에서 사용되던 **공개 키(public key)**를 HS256(대칭 알고리즘)의 **비밀 키(secret key)**로 재활용하게 만든다.

3. 서버가 클라이언트가 보낸 alg 값을 신뢰하고 검증 로직을 수행한다면, 공개 키를 비밀 키로 사용하여 서명을 검증하게 된다. 이 과정에서 공격자가 HS256 알고리즘으로 서명한 토큰이 유효한 것으로 판단된다.

#### 공개키 획득 방법
Algorithm Confusion 공격을 성공적으로 수행하려면 서버에서 사용하는 공개 키를 획득해야 한다. 
1. 공개 키가 노출된 경우  
   공개 키는 일반적으로 노출되어도 큰 문제가 되지 않지만, 특정 환경에서는 이를 악용할 수 있다. 많은 서버는 공개 키를 배포하기 위해 /.well-known/jwks.json 엔드포인트를 사용한다. 이는 JSON Web Key Set(JWKS) 형식으로 공개 키를 반환한다. 공격자는 해당 엔드포인트에 요청을 보내 공개 키를 획득할 수 있다.  
   ```
   GET /.well-known/jwks.json HTTP/1.1
   Host: example.com
   ```
   ```json
   {
     "keys": [
       {
         "kty": "RSA",
         "kid": "key1",
         "use": "sig",
         "n": "base64-encoded-modulus",
         "e": "AQAB"
       }
     ]
   }
   ```

2. 공개 키가 코드나 설정 파일에 포함된 경우  
   개발자가 실수로 공개 키를 코드나 설정 파일에 포함하고 이를 공개 저장소(예: GitHub)에 업로드할 수 있다. 공격자는 이러한 저장소를 검색하여 공개 키를 쉽게 획득할 수 있다.  
   `n:"base64-encoded-modulus"` 또는 `BEGIN PUBLIC KEY`와 같은 문자열을 검색하면 노출된 공개 키를 찾을 수 있다.  

3. 공개 키가 HTTP 응답 헤더나 메시지에 포함된 경우  
   일부 서버는 JWT를 발급할 때 공개 키를 HTTP 응답 헤더나 메시지의 메타데이터에 포함하여 제공한다. 이 경우 공격자는 네트워크 트래픽을 가로채거나 단순한 HTTP 요청으로 공개 키를 획득할 수 있다.  

4. MITM(중간자 공격)으로 공개 키 획득  
   서버와 클라이언트 간의 통신이 암호화되지 않았거나, HTTPS가 올바르게 설정되지 않은 경우 공격자는 네트워크 트래픽을 가로채서 JWT와 함께 전송된 공개 키를 획득할 수 있다.  

5. 취약한 키 관리 시스템을 이용한 획득  
   서버가 키를 관리할 때 취약한 파일 경로나 잘못된 접근 제어를 설정해둔 경우, 공격자는 서버 내부의 키 파일이나 키 저장소를 직접 접근하여 공개 키를 획득할 수 있다.  
   공격자가 서버의 디렉토리 구조를 탐색하거나 `kid` 필드 취약점을 악용하여 키 파일을 다운로드 받을 수 있다.  

6. 공개 키를 직접 제공하는 API  
   일부 API는 개발자가 디버깅 또는 테스트 목적으로 공개 키를 직접 요청할 수 있도록 설계되었다. 공격자는 이 API를 악용하여 공개 키를 획득할 수 있다.  

7. 공개 키를 추측  
   공개 키는 일반적으로 긴 문자열이지만, 짧거나 단순한 키를 사용하는 경우 공격자가 무작위 대입(brute force) 공격으로 키를 추측할 수 있다.

### JWK Injection Attack
JWK(JSON Web Key)는 JWT의 서명을 검증하기 위해 사용되는 공개 키를 정의하는 JSON 형식의 데이터 구조이다. JWK Injection은 공격자가 악의적인 JWK 데이터를 서버에 전달하여 자신의 서명을 유효한 것으로 검증하게 만드는 공격 기법이다.

#### 공격 원리
1. JWK의 kid(Key ID) 필드 악용  
서버는 JWT를 검증할 때, 토큰의 Header에 포함된 `kid`(Key ID) 값을 사용하여 JWK를 조회한다. 이 `kid` 값을 서버가 신뢰하거나 적절히 검증하지 않을 경우, 공격자는 `kid` 값을 악의적으로 조작하여 서버가 잘못된 키를 사용하도록 유도할 수 있다.  

2. 공격자가 악성 JWK 제공  
공격자는 자신이 만든 JWK를 서버가 사용하도록 유도하고, 이 JWK에 해당하는 개인 키로 서명한 JWT를 서버에 전송한다. 서버가 이를 신뢰하면, 공격자가 생성한 JWT를 유효한 것으로 간주하게 된다.  

3. 알고리즘 변경과 결합된 공격  
JWK Injection은 알고리즘 변경 공격과 결합되면 더욱 심각한 문제가 된다. 예를 들어, 공격자는 토큰의 알고리즘을 HS256에서 RS256으로 변경하고, 공개 키를 제공하는 방식으로 공격을 강화할 수 있다.  

#### 공격 시나리오오
1. 공격자에 의한 JWT Header 변조  
   공격자는 JWT의 Header를 다음과 같이 수정한다:  
    ```json
    {
    "alg": "RS256",
    "kid": "malicious-key-id"
    }
    ```
2. 악성 JWK 서버 제공  
   공격자는 자신의 서버에서 아래와 같은 악성 JWK를 제공한다:  
    ```json
    {
    "keys": [
        {
        "kty": "RSA",
        "kid": "malicious-key-id",
        "n": "base64-encoded-modulus",  // 공개 키의 모듈러스
        "e": "AQAB"                    // 공개 키의 지수
        }
    ]
    }
    ```
3. 서버의 잘못된 JWK 조회  
   서버가 `kid` 값으로 JWK를 찾고, 공격자가 제공한 JWK를 신뢰하면, 공격자가 서명한 토큰이 유효한 것으로 검증된다.  
4. 공격자 권한 상승  
   공격자는 `admin`과 같은 권한을 가진 JWT를 만들어 서버에 전달하고, 서버는 이를 신뢰하여 공격자에게 높은 권한을 부여한다.

### KID Injection Attack
`kid`(Key ID)는 JWT의 Header에서 사용되며, 서버가 적절한 서명 키를 선택하도록 돕는 식별자 역할을 한다.  
`kid` 필드가 적절히 검증되지 않거나 서버에서 이를 신뢰할 경우, 공격자는 kid 값을 조작하여 서버가 잘못된 키를 사용하도록 유도하거나 악의적인 동작을 수행하게 만들 수 있다.  

#### 공격 원리
1. JWT의 Header에는 `kid` 필드가 포함될 수 있다:
    ```json
    {
    "alg": "HS256",
    "kid": "key1"
    }
    ```
    서버는 이 `kid`값을 참조하여 내부 키 저장소나 외부 키 관리 시스템에서 적합한 키를 로드해 서명을 검증한다.  

2. 공격자는 `kid`값을 악의적으로 조작하여 서버가 예상치 못한 동작을 수행하게 만든다. 이를 통해 공격자는: 
   * 잘못된 키를 사용하도록 유도하거나,
   * 파일 경로 탐색(Path Traversal) 등을 통해 시스템 파일에 접근하거나,
   * 자신의 악성 키로 서명을 검증하도록 서버를 속일 수 있다.

#### 공격 시나리오
1. Path Traversal을 이용한 파일 접근  
   * 공격자는 `kid` 값을 파일 경로로 변조한다.  
        ```json
        {
        "alg": "HS256",
        "kid": "../../../etc/passwd"
        }
        ```
   * 서버가 `kid`를 파일 경로로 해석하여 해당 경로의 파일을 키로 사용하려고 하면, 공격자는 서버의 민감한 파일(예: `/etc/passwd`)에 접근할 수 있다.  
   * 
2. 외부 키 서버로 유도  
   * 공격자는 kid 값을 자신이 제어하는 외부 URL로 설정한다.  
        ```json
        {
        "alg": "HS256",
        "kid": "http://attacker.com/malicious-key"
        }
        ```
   * 서버가 동적으로 키를 로드하려고 할 경우, 공격자는 자신의 공개 키를 제공해 서명 검증을 우회할 수 있다.  

3. 임의키 사용을 통한 서명 우회  
   * 공격자는 `kid` 값을 키 저장소에서 존재하지 않는 키로 설정한다.
        ```json
        {
        "alg": "HS256",
        "kid": "nonexistent-key"
        }
        ```
   * 서버가 기본 키나 다른 예기치 않은 키를 사용하여 서명 검증을 시도하면, 공격자는 이를 악용해 자신의 서명을 유효한 것으로 만들 수 있다.

### JKU Spoofing Attack
JWT의 Header에는 `jku` 필드가 포함될 수 있다. 이 필드는 JSON Web Key Set(JWKS)을 제공하는 URL을 지정하며, 서버가 이 URL에서 공개 키를 가져와 JWT 서명을 검증하도록 설계되었다. 공격자는 이 `jku` 값을 악의적으로 조작하여 서버가 자신의 악성 JWKS URL을 참조하게 만들 수 있다. 이를 통해 공격자는 자신이 서명한 변조된 JWT를 유효한 것으로 서버가 검증하도록 속일 수 있다.

#### 공격 원리
1. 정상적인 JWT 구성  
   * JWT의 Header는 `jku` 필드를 포함할 수 있다. 예를 들어:  
        ```json
        {
        "alg": "RS256",
        "typ": "JWT",
        "jku": "https://legitimate-domain.com/.well-known/jwks.json"
        }
        ```  
        서버는 `jku` 필드의 URL에서 공개 키를 가져와 JWT 서명을 검증한다.  

2. 공격자의 악의적인 변조
   * 공격자는 JWT Header의 `jku` 필드를 자신이 제어하는 URL로 변경한다.  
        ```json
        {
        "alg": "RS256",
        "typ": "JWT",
        "jku": "https://attacker-domain.com/malicious-jwks.json"
        }
        ```  

3. 공격자가 제어하는 JWKS  
   * 공격자는 자신의 서버에서 다음과 같은 악성 JWKS를 제공한다:
        ```json
        {
        "keys": [
            {
            "kty": "RSA",
            "kid": "malicious-key-id",
            "n": "base64-encoded-modulus",  // 공개 키의 모듈러스
            "e": "AQAB"                    // 공개 키의 지수
            }
        ]
        }
        ```
        공격자는 이 공개 키에 해당하는 개인 키로 서명한 변조된 JWT를 서버에 전송한다.  

4. 서버의 잘못된 신뢰
   * 서버가 `jku` 값을 검증하지 않고 그대로 신뢰하여 공격자의 JWKS를 로드하면, 공격자가 제공한 공개 키로 JWT 서명을 검증하게 된다.
   * 결과적으로, 공격자가 변조한 JWT가 유효한 것으로 서버가 판단하게 된다.

#### 공격 시나리오
1. 공격대상: RS256 알고리즘을 사용하는 JWT 인증 시스템  
   
2. JWT 변조: 공격자는 정상적인 JWT의 Header를 다음과 같이 수정한다:  
```json
{
    "alg": "RS256",
    "typ": "JWT",
    "jku": "https://attacker.com/malicious-jwks.json"
}
```

3. 악성 JWKS 제공  
   * 공격자는 `https://attacker.com/malicious-jwks.json`에 자신이 생성한 공개 키를 포함한 JWKS를 호스팅한다.  
  
4. 변조된 JWT 생성  
   * 공격자는 자신이 제공한 JWKS 공개 키에 대응하는 개인 키로 변조된 JWT를 생성한다.  

5. 공격 성공
   * 서버가 `jku`를 통해 공격자의 악성 JWKS URL에서 키를 로드하면, 공격자가 변조한 JWT를 유효한 것으로 판단한다.  
   * 공격자는 서버에서 `admin` 권한을 얻거나 보호된 리소스에 접근할 수 있다.